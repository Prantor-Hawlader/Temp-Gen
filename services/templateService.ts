import { TemplateType, GeneratedFile, ProjectOptions } from "../types";

/**
 * Generates template files for the selected stack
 */
export const generateFiles = (
  projectName: string,
  template: TemplateType,
  options: ProjectOptions = { includeTests: true, includeLinter: true },
): GeneratedFile[] => {
  const withProjectName = (content: string) =>
    content.replace(/{{PROJECT_NAME}}/g, projectName);

  if (template === TemplateType.TYPESCRIPT_EXPRESS) {
    return [
      {
        path: "package.json",
        language: "json",
        content: withProjectName(
          JSON.stringify(
            {
              name: "{{PROJECT_NAME}}",
              version: "1.0.0",
              description:
                "Standardized Node.js microservice generated by temp-gen",
              main: "dist/index.js",
              scripts: {
                start: "node dist/index.js",
                dev: "ts-node-dev --respawn src/index.ts",
                build: "tsc",
                test: "jest",
                "test:watch": "jest --watchAll",
              },
              dependencies: {
                express: "^4.18.2",
                cors: "^2.8.5",
                helmet: "^7.1.0",
                dotenv: "^16.3.1",
                winston: "^3.11.0",
              },
              devDependencies: {
                typescript: "^5.2.2",
                "@types/node": "^20.8.2",
                "@types/express": "^4.17.18",
                "@types/cors": "^2.8.14",
                "@types/jest": "^29.5.5",
                "@types/supertest": "^2.0.14",
                "ts-node-dev": "^2.0.0",
                jest: "^29.7.0",
                "ts-jest": "^29.1.1",
                supertest: "^6.3.3",
              },
            },
            null,
            2,
          ),
        ),
      },
      {
        path: "tsconfig.json",
        language: "json",
        content: JSON.stringify(
          {
            compilerOptions: {
              target: "ES2020",
              module: "CommonJS",
              outDir: "./dist",
              rootDir: "./src",
              strict: true,
              esModuleInterop: true,
              skipLibCheck: true,
              forceConsistentCasingInFileNames: true,
            },
            include: ["src/**/*"],
            exclude: ["node_modules", "**/*.test.ts"],
          },
          null,
          2,
        ),
      },
      {
        path: "src/index.ts",
        language: "typescript",
        // Fix: correctly escape template literal placeholders and backticks
        content: withProjectName(`import app from './app';
import { logger } from './utils/logger';

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  logger.info(\`[{{PROJECT_NAME}}] Server listening on port \${PORT}\`);
});`),
      },
      {
        path: "src/app.ts",
        language: "typescript",
        content: `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import { healthRouter } from './routes/health.routes';

const app = express();

app.use(helmet());
app.use(cors());
app.use(express.json());

// Routes
app.use('/health', healthRouter);

export default app;`,
      },
      {
        path: "src/routes/health.routes.ts",
        language: "typescript",
        content: `import { Router } from 'express';
import { HealthController } from '../controllers/health.controller';

const router = Router();
const controller = new HealthController();

router.get('/', (req, res) => controller.getStatus(req, res));

export { router as healthRouter };`,
      },
      {
        path: "src/controllers/health.controller.ts",
        language: "typescript",
        content: `import { Request, Response } from 'express';
import { HealthService } from '../services/health.service';

export class HealthController {
  private healthService: HealthService;

  constructor() {
    this.healthService = new HealthService();
  }

  public getStatus(req: Request, res: Response): void {
    const status = this.healthService.getSystemHealth();
    res.status(200).json(status);
  }
}`,
      },
      {
        path: "src/services/health.service.ts",
        language: "typescript",
        content: `export class HealthService {
  public getSystemHealth() {
    return {
      status: 'UP',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage()
    };
  }
}`,
      },
      {
        path: "src/utils/logger.ts",
        language: "typescript",
        content: `import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple(),
    }),
  ],
});`,
      },
      ...(options.includeLinter
        ? [
            {
              path: ".eslintrc.json",
              language: "json",
              content: JSON.stringify(
                {
                  env: { node: true, es2024: true },
                  extends: ["eslint:recommended"],
                  parserOptions: { ecmaVersion: 2024, sourceType: "module" },
                  rules: {
                    "no-unused-vars": ["error", { argsIgnorePattern: "^_" }],
                    "no-console": ["warn"],
                    quotes: ["error", "single"],
                    semi: ["error", "always"],
                  },
                },
                null,
                2,
              ),
            },
          ]
        : []),
      ...(options.includeTests
        ? [
            {
              path: "src/tests/health.test.ts",
              language: "typescript",
              content: `import request from 'supertest';
import app from '../app';

describe('Health Endpoint', () => {
  it('should return 200 OK and status UP', async () => {
    const response = await request(app).get('/health');
    expect(response.status).toBe(200);
    expect(response.body.status).toBe('UP');
    expect(response.body).toHaveProperty('timestamp');
  });
});`,
            },
          ]
        : []),
      {
        path: "jest.config.js",
        language: "javascript",
        content: `module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/*.test.ts'],
};`,
      },
      {
        path: "Dockerfile",
        language: "dockerfile",
        content: `# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: Runtime
FROM node:18-alpine
WORKDIR /app
ENV NODE_ENV=production
COPY package*.json ./
RUN npm ci --only=production
COPY --from=builder /app/dist ./dist
EXPOSE 3000
CMD ["node", "dist/index.js"]`,
      },
      {
        path: ".dockerignore",
        language: "text",
        content: `node_modules\ndist\n.git\nDockerfile\n.dockerignore\nnpm-debug.log`,
      },
    ];
  } else if (template === TemplateType.GO_CLEAN_ARCH) {
    return [
      {
        path: "go.mod",
        language: "go",
        content: withProjectName(`module github.com/engineering/{{PROJECT_NAME}}

go 1.21

require (
	github.com/golang-jwt/jwt/v5 v5.2.0
	github.com/google/uuid v1.6.0
	go.uber.org/zap v1.26.0
)`),
      },
      {
        path: "cmd/api/main.go",
        language: "go",
        content: withProjectName(`package main

import (
	"log"
	"net/http"
	"os"

	"github.com/engineering/{{PROJECT_NAME}}/internal/middleware"
	"go.uber.org/zap"
)

func main() {
	logger, _ := zap.NewProduction()
	defer logger.Sync()

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	mux := http.NewServeMux()

	// Health check
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte("{\\"status\\":\\"UP\\",\\"service\\":\\"{{PROJECT_NAME}}\\"}"))
	})

	// Protected routes example
	mux.Handle("/api/v1/secure", middleware.Auth(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Access granted"))
	})))

	// Wrap with logger middleware
	handler := middleware.Logger(logger, mux)

	logger.Info("Starting server", zap.String("port", port), zap.String("service", "{{PROJECT_NAME}}"))
	if err := http.ListenAndServe(":"+port, handler); err != nil {
		log.Fatalf("Server failed: %s", err)
	}
}`),
      },
      {
        path: "internal/domain/user.go",
        language: "go",
        // Fix: properly escape struct tags in Go source strings
        content: `package domain

import "context"

type User struct {
	ID    string \`json:"id"\`
	Email string \`json:"email"\`
}

type UserRepository interface {
	GetByID(ctx context.Context, id string) (*User, error)
}

type UserUsecase interface {
	GetProfile(ctx context.Context, id string) (*User, error)
}`,
      },
      {
        path: "internal/usecase/user_usecase.go",
        language: "go",
        content: `package usecase

import (
	"context"
	"github.com/engineering/{{PROJECT_NAME}}/internal/domain"
)

type userUsecase struct {
	userRepo domain.UserRepository
}

func NewUserUsecase(repo domain.UserRepository) domain.UserUsecase {
	return &userUsecase{userRepo: repo}
}

func (u *userUsecase) GetProfile(ctx context.Context, id string) (*domain.User, error) {
	return u.userRepo.GetByID(ctx, id)
}`,
      },
      {
        path: "internal/middleware/auth.go",
        language: "go",
        content: `package middleware

import (
	"net/http"
	"strings"

	"github.com/golang-jwt/jwt/v5"
)

func Auth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			http.Error(w, "Invalid token format", http.StatusUnauthorized)
			return
		}

		// Validation logic (Simplified)
		tokenString := parts[1]
		token, _ := jwt.Parse(tokenString, func(t *jwt.Token) (interface{}, error) {
			return []byte("secret-key"), nil
		})

		if token != nil && token.Valid {
			next.ServeHTTP(w, r)
		} else {
			http.Error(w, "Invalid token", http.StatusUnauthorized)
		}
	})
}`,
      },
      {
        path: "internal/middleware/logger.go",
        language: "go",
        content: `package middleware

import (
	"net/http"
	"time"

	"go.uber.org/zap"
)

func Logger(logger *zap.Logger, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		
		logger.Info("Request Handled",
			zap.String("method", r.Method),
			zap.String("path", r.URL.Path),
			zap.Duration("latency", time.Since(start)),
		)
	})
}`,
      },
      {
        path: "Dockerfile",
        language: "dockerfile",
        content: `# Stage 1: Build
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main ./cmd/api/main.go

# Stage 2: Runtime
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
EXPOSE 8080
CMD ["./main"]`,
      },
      {
        path: ".dockerignore",
        language: "text",
        content: `vendor\nbin\n.git\nDockerfile\n.dockerignore`,
      },
      ...(options.includeLinter
        ? [
            {
              path: ".golangci.yml",
              language: "yaml",
              content: `run:
  deadline: 5m
  skip-dirs:
    - vendor

linters:
  enable:
    - errcheck
    - govet
    - gofmt
    - ineffassign
    - vet

linters-settings:
  errcheck:
    check-type-assertions: true`,
            },
          ]
        : []),
    ];
  } else {
    // Template for the CLI Tool itself (temp-gen source)
    return [
      {
        path: "package.json",
        language: "json",
        content: withProjectName(
          JSON.stringify(
            {
              name: "temp-gen",
              version: "1.0.0",
              description:
                "Engineering Enablement CLI to scaffold standardized microservices.",
              bin: { "temp-gen": "./dist/index.js" },
              scripts: {
                build: "tsc",
                start: "node dist/index.js",
                link: "npm run build && npm link",
              },
              dependencies: {
                commander: "^11.0.0",
                inquirer: "^9.2.0",
                "fs-extra": "^11.1.0",
                chalk: "^4.1.2",
              },
              devDependencies: {
                typescript: "^5.0.0",
                "@types/node": "^20.0.0",
                "@types/fs-extra": "^11.0.0",
                "@types/inquirer": "^9.0.0",
              },
            },
            null,
            2,
          ),
        ),
      },
      ...(options.includeLinter
        ? [
            {
              path: ".eslintrc.json",
              language: "json",
              content: JSON.stringify(
                {
                  env: { node: true, es2024: true },
                  extends: ["eslint:recommended"],
                  parserOptions: { ecmaVersion: 2024, sourceType: "module" },
                  rules: {
                    "no-unused-vars": ["error", { argsIgnorePattern: "^_" }],
                    "no-console": ["warn"],
                    quotes: ["error", "single"],
                    semi: ["error", "always"],
                  },
                },
                null,
                2,
              ),
            },
          ]
        : []),
      {
        path: "README.md",
        language: "markdown",
        content: `# Temp-Gen: Microservice Template Generator

A CLI tool to bootstrap production-ready microservices in Node.js/TypeScript or Go with standardized architecture patterns.

## üöÄ Features

- **Multiple Stacks**: TypeScript/Express and Go/Clean-Arch templates
- **Consistency**: Ensures all services follow the same architectural patterns
- **Production-Ready**: Pre-configured with logging, health checks, and Docker support
- **Fast Setup**: Scaffold a new microservice in seconds

## üì¶ Installation

\`\`\`bash
npm install -g temp-gen
\`\`\`

## üéØ Usage

Create a new microservice:

\`\`\`bash
temp-gen my-service
\`\`\`

You'll be prompted to select:
1. **Stack**: TypeScript/Express or Go/Clean-Arch
2. The tool will generate the project structure with all necessary files

## üèóÔ∏è What's Included

### TypeScript/Express Template
- Express.js server setup
- Structured logging with Winston
- Health check endpoint
- Jest testing framework
- Docker multi-stage build
- TypeScript configuration

### Go/Clean-Arch Template
- Clean Architecture pattern
- JWT authentication middleware
- Structured logging with Zap
- Docker multi-stage build
- Standard Go project layout

## üìù Commands

\`\`\`bash
# Build the CLI
npm run build

# Run the CLI directly (after build)
node dist/index.js my-service
\`\`\`

## ü§ù Contributing

To add a new template or improve existing ones, submit a PR with your enhancements.

---

Made by Prantor Hawlader | Simplifying microservice scaffolding`,
      },
      {
        path: "src/index.ts",
        language: "typescript",
        // Fix: Ensure all backticks and colors (chalk.blue instead of indigo) are correct
        content: `import { Command } from 'commander';
import inquirer from 'inquirer';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

const program = new Command();

program
  .name('temp-gen')
  .description('Scaffold standardized microservices with Clean Architecture')
  .version('1.0.0')
  .argument('<project-name>', 'Name of the project to create')
  .action(async (projectName: string) => {
    console.log(chalk.blue(\`\\nüöÄ Initializing temp-gen for project: \${projectName}\\n\`));

    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'template',
        message: 'Which architectural stack would you like to use?',
        choices: ['TypeScript/Express', 'Go/Clean-Arch'],
      }
    ]);

    const targetDir = path.join(process.cwd(), projectName);
    // Note: In a real binary, templates would be packaged with the tool
    const templateName = answers.template === 'TypeScript/Express' ? 'ts-express' : 'go-clean';
    const templateDir = path.join(__dirname, '..', 'templates', templateName);

    try {
      if (await fs.pathExists(targetDir)) {
        console.error(chalk.red(\`Error: Directory \${projectName} already exists.\`));
        process.exit(1);
      }

      console.log(chalk.blue('  - Copying template files...'));
      // In this demo context, we assume the templates are available.
      // In production, you might fetch these from a registry or embed them.
      await fs.copy(templateDir, targetDir);

      console.log(chalk.blue('  - Customizing project metadata...'));
      await walkAndReplace(targetDir, projectName);

      console.log(chalk.green(\`\\n‚úÖ Success! Project \${projectName} is ready at \${targetDir}\\n\`));
    } catch (err) {
      console.error(chalk.red('Fatal error during generation:'), err);
    }
  });

/**
 * Recursively walks through files and replaces placeholders
 */
async function walkAndReplace(dir: string, projectName: string) {
  const files = await fs.readdir(dir);

  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = await fs.stat(fullPath);

    if (stat.isDirectory()) {
      await walkAndReplace(fullPath, projectName);
    } else {
      let content = await fs.readFile(fullPath, 'utf8');
      if (content.includes('{{PROJECT_NAME}}')) {
        content = content.replace(/{{PROJECT_NAME}}/g, projectName);
        await fs.writeFile(fullPath, content, 'utf8');
      }
    }
  }
}

program.parse();`,
      },
      {
        path: "tsconfig.json",
        language: "json",
        // Fix: Explicitly define language and content properties
        content: JSON.stringify(
          {
            compilerOptions: {
              target: "ES2020",
              module: "CommonJS",
              outDir: "./dist",
              rootDir: "./src",
              strict: true,
              esModuleInterop: true,
              skipLibCheck: true,
            },
          },
          null,
          2,
        ),
      },
    ];
  }
};
